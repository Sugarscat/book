# 企业级开发

## 必备知识

**在`Java`编程语言中，请描述一下重载和重写的区别？**

在Java编程语言中，"重载"（Overloading）和"重写"（Overriding）是两种非常常见但有明显不同的概念。以下是它们的主要区别：

 1. 定义：

- 重载（Overloading）是指在同一类中，方法名相同但参数列表（参数类型、数量、顺序）不同的方法。
- 重写（Overriding）是子类中定义了一个与父类中同名同参数的方法。

 2. 目的：
    - 重载是为了增加方法的可读性。在同一类中，我们可以通过相同的名称但不同的参数列表来区分不同的方法。
    - 重写是为了改变父类方法在子类中的行为。如果子类需要父类的某个方法，但希望它的行为略有不同，那么就可以重写这个方法。

 3. 处理机制：
    - 重载在编译时期就可以确定，因为编译器通过参数列表的不同来选择调用哪个方法。
    - 重写只有在运行时期才能确定，因为运行时期才清楚对象的实际类型（即调用哪个类的方法）。

 4. 访问修饰符：
    - 重载的方法可以改变访问修饰符，即可以是public,      protected, default (取决于具体的Java编译器或者环境)。
    - 重写的方法不能改变访问修饰符，它必须和被重写的方法具有相同的访问权限或者更严格的访问权限。

 5. 返回类型：
    - 重载的方法可以有不同的返回类型。
    - 重写的方法返回类型必须与被重写的方法的返回类型相同或是其子类。

 6. 异常：
    - 重载的方法可以有不同的异常列表。
    - 重写的方法不能抛出新的检查性异常或者比被重写的方法声明的更广的检查性异常，其他方面的异常可以与被重写的方法声明的异常相同、更少、或者没有。

**谈一谈面向对象的三大特征？**

- 封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。这是面向对象的特征之一，是对象和类概念的主要特性。简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。
  
- 继承：可以让某个类型的对象获得另一个类型的对象的属性或方法。它支持按级分类的概念，继承概念的实现方式有实现继承与接口继承。
  
- 多态：让具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。

**谈一谈多态形成三大条件？**

 多态形成的三大条件是继承、方法重写和向上转型。

- 继承：多态要求存在继承关系，具体类（子类）继承自抽象类或接口（父类），并且具体类需要实现或覆盖父类的方法。
  
- 方法重写：子类需要重写（覆盖）父类的方法。重写意味着子类提供了自己的实现，而不是简单地继承父类的方法。
  
- 向上转型：通过父类的引用来引用子类的对象。

**谈一谈`Object`类中常用方法以及描述下该方法的功能？**

  Object类是Java中所有类的超类，其定义了一些常用的方法，这些方法可以在Java程序中的任何地方使用。以下是一些常用的Object类方法及其功能描述：

- equals(Object obj):     该方法用于比较两个对象是否相等。默认情况下，它比较的是两个对象的内存地址，但在某些情况下，可能需要覆盖该方法以实现自定义的相等比较。
- hashCode():     该方法返回一个int类型的哈希值，该值通常用于哈希表。这个方法默认也是基于对象的内存地址进行计算，但也可以在需要时覆盖以实现自定义的哈希值计算。
- toString():     该方法返回一个对象的字符串表示。这个方法可以用来将对象转化为可读的字符串形式，有助于调试和日志记录。该方法默认返回的是对象的类名以及哈希码的十六进制表示，但也可以在需要时覆盖以提供自定义的字符串表示。
- getClass():     该方法返回一个对象的运行时类，即该对象实际所属的类。通过该方法，我们可以获取对象的类型信息。
- notify():     该方法用于唤醒在此对象监视器上等待的一个线程。当一个线程在某个对象上调用wait()方法后，它就会在该对象的监视器上等待，直到其他线程调用该对象的notify()方法或notifyAll()方法。
- notifyAll():     该方法用于唤醒在某个对象监视器上等待的所有线程。当一个线程在某个对象上调用wait()方法后，它就会在该对象的监视器上等待，直到其他线程调用该对象的notify()方法或notifyAll()方法。
- wait(long timeout):     该方法导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者超过指定的时间量。
- wait(long timeout, int     nanos):     该方法导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。这个方法比上一个方法更为精确，可以指定额外的纳秒时间量。

**谈一谈集合中常用的类或接口以及他们的区别？**

  在Java集合框架中，常用的类和接口包括Vector、ArrayList、LinkedList、Set、List、Map等。

- Vector和ArrayList：二者都是存储数据的容器，但是它们在同步性和数据增长方式上存在差异。Vector是线程安全的（同步），而ArrayList是线程不安全的。当需要增长时，Vector默认增长一倍，而ArrayList却增长一半。
- LinkedList：实现了List接口，允许null元素对象，此外LinkedList提供额外的get、remove、insert方法在LinkedList的首部或尾部。和ArrayList相比，LinkedList在插入、删除元素时，效率会更高。
- Set：无序的、不重复的元素集合。其中的元素不能重复，至少有一个元素。它包括HashTable和LinkedHashSet等实现类。
- Map：存储键值对的数据集，可能有重复的键（在HashTable中），至少有一个元素。Map的两个关键接口是Map和SortedMap。
  
  ::: tip 注意
  具体选择哪种类型的集合，取决于具体的应用和需求。如果需要一个线程安全的集合，那么可以选择Vector或者HashTable；如果需要一个具有排序功能的集合，那么可以选择TreeSet或者TreeMap；如果需要处理List中经常被访问的元素，那么可以选择LinkedHashSet或者LinkedHashMap。
  :::

**谈一谈 String、StringBuffer、StringBuilder 的区别？**

  String、StringBuffer 和 StringBuilder 都是 Java 中用于处理字符串的类，但它们之间有以下区别：

- 可变性：String 类是不可变的，而 StringBuffer 和 StringBuilder 是可变的。这意味着 String 类的对象一旦创建，其内容就不能更改，而 StringBuffe 和 StringBuilder 类的对象可以修改其内容。
- 线程安全：String 类和 StringBuffer 类是线程安全的，而 StringBuilder 类是非线程安全的。因为 String 类的对象是不可变的，所以它是线程安全的。StringBuffer 类通过对调用的方法加入同步锁来保证线程安全，但这也降低了执行效率。StringBuilder 类没有同步措施，因此可以在单线程环境下使用，并在必要时提高执行效率。
- 性能：在执行字符串拼接等操作时，StringBuffer 和 StringBuilder 的性能高于 String。因为String类的对象是不可变的，每次执行字符串拼接操作都会创建一个新的String对象，这导致了大量的内存分配和垃圾回收，从而降低了性能。而 StringBuffer 和 StringBuilder 类的对象是可变的，它们可以在原来的基础上进行追加，避免了频繁的内存分配和垃圾回收，因此性能更高。
  
  综上所述，在处理字符串时，如果需要频繁修改字符串内容，应使用 StringBuffer 或 StringBuilder；如果不需要修改字符串内容，或者需要保证线程安全，应使用 String。

**String str=”a”+”b”+”c”;  会创建几个对象 常量池？**

 String str=“abc”;如果存在编译优化中？

 0 1 2  3  4  5

**谈一谈 List  set  map 三种集合的区别？**

 List、Set和Map是Java中的三种集合，它们分别具有不同的特点和用途。

 1. List：有序、可重复。List是一个有序的集合，允许包含重复的元素。它是基于索引的，可以通过索引访问元素。常见的实现类包括ArrayList和LinkedList等。
 2. Set：无序、不可重复的集合。Set是一个无序的集合，不允许包含重复的元素。它是基于集合运算的，可以执行添加、删除、交集等操作。常见的实现类包括HashSet和TreeSet等。
 3. Map：键值对，键唯一、值不唯一。Map是一个键值对的集合，每个元素都包含一个键和一个值，键是唯一的，但值可以重复。它是基于键值对的，可以通过键来访问值。常见的实现类包括HashMap和TreeMap等。

 总的来说，List、Set和Map分别用于存储有序的可重复元素集合、无序的不可重复元素集合和键值对集合。它们的使用取决于具体的应用场景和需求。

**谈一谈数组和链表有什么区别？**

 数组和链表是两种常用的数据存储结构，它们在以下几个方面存在差异：

 1. 存储形式：数组是一块连续的内存空间，声明时需要确定其长度。而链表是动态的，由一个个节点组成，每个节点包含数据和指向下一个节点的指针，因此链表的长度可以动态变化。
 2. 数据查找：数组的查找速度相对较快，因为可以通过索引直接访问元素。然而，链表的查找速度相对较慢，因为需要按顺序遍历节点。
 3. 数据插入和删除：在数组中插入和删除元素可能需要移动大量数据，因为需要保持数组的连续性。而链表在这方面具有优势，插入和删除节点只需要修改指针即可。
 4. 越界问题：数组存在越界问题，因为数组的长度是固定的。如果尝试访问超出数组长度的位置，可能会导致程序崩溃。而链表不存在越界问题，可以随时添加或删除节点。
 5. 空间使用：链表需要额外的空间来存储节点和指针，因此链表占用的内存空间可能比数组多。

 综上所述，数组和链表各有其优缺点。在选择使用时，需要根据实际需求来选择。例如，如果需要频繁访问数据且数据量不大，可以使用数组；如果需要动态添加或删除数据，可以使用链表。

**在 Java 编程语言中，请描述一下多线程的生命周期以及对应的方法？**

 在Java中，多线程的生命周期可以分为四个主要阶段，与每个阶段对应的是一些关键方法：

 1. 创建阶段（Creation）

	这个阶段对应于使用 new 关键字创建一个新的线程。创建线程时，需要实现 Runnable 接口或者继承 Thread 类。
	```java
	Thread thread = new Thread(new RunnableTask()); // 通过实现Runnable接口创建线程 
	Thread thread = new Thread(task); // 通过继承Thread类创建线程 
	```

 2. 启动阶段（Running）

    这个阶段对应于调用 start() 方法来启动线程。一旦线程被启动，它就会从 run() 方法开始执行。

    ```java
    thread.start(); // 启动线程
    ```

 3. 运行阶段（Running and Suspended）

    这个阶段是线程正在执行其任务，或者由于调用了 sleep()，join() 或者 wait() 方法而处于暂停状态的阶段。

    ```java
    thread.sleep(1000); // 使线程暂停1秒                     
    thread.join(1000); // 使当前线程等待指定线程结束后继续执行，超时时间为1秒 
    thread.wait(); // 使线程进入等待状态，直到其他线程调用notify()或notifyAll()方法唤醒
    ```

 4. 终止阶段（Termination）

    当线程完成任务或者由于异常导致其结束时，它就进入了终止阶段。此时线程不再是活动的，无法再次启动。可以通过调用 isAlive() 方法来检查线程是否还活着（即是否已经退出）。如果返回 false，则线程已经退出。

    ```java
    if (!thread.isAlive())  {  
        System.out.println("Thread has finished."); 
    }
    ```

    值得注意的是，Java 5以后引入了一个新的线程模型，叫做Executor Framework，这个框架中包括了Executor, ExecutorService, Executors, Future, Callable等新的工具，让线程的管理和运用更加灵活高效。在新代码中，通常推荐使用这个框架，而不是直接使用Thread类来创建和管理线程。

**谈一谈 `块级标签` 、`行级标签`、 `行块标签` 有哪些有什么区别？**

 块级标签、行级标签和行块标签是HTML中的三种标签类型，它们的主要区别在于如何显示和处理内容。

- 块级标签在HTML中独自占一行，可以设定宽高属性值，对宽高的属性值生效。例如，`<p>` 标签（段落标签）就是块级标签，默认情况下，段落的文字会从新的一行开始，并且占据整行的宽度。

- 行级标签可以在一行内显示，不可以设定宽高属性值，它的宽度默认为其内容的宽度。行级标签对宽高属性值不生效，完全靠内容撑开宽高。例如，`<a>`、`<span>`、`<strong>`、`<img>`、`<input>`等都是行级标签。

- 行块标签结合了块级标签和行级标签的优点，既可以设定宽高属性值，又可以在一行内显示。例如，`<ul>`、`<li>`等都是行块标签。

 总的来说，块级标签、行级标签和行块标签的主要区别在于显示方式、是否可以设定宽高属性值，以及是否可以和其他元素并排显示。它们各自具有不同的使用场景和特点，根据实际需求选择使用。

**在一个完整的线程生命周期里，需要经过：新建—>就绪—>运行—>阻塞—>死亡 一共5个状态。**

1. 新建：就是new了一个Thread对象，此时还未执行start()方法.

2. 就绪：当Thread对象执行了start()方法后，线程就处于了就绪状态。即告诉 JVM “我已经准备好了，随时可以来分配时间片给我，让我执行”。此时 JVM 就会为它创建一些基本的调用前的准备，如创建方法调用栈、程序计数器等，等待调用运。

3. 运行：处于就绪状态的线程分配到了cpu的时间片，得到了cpu的调用，开始运行其run()方法 ，此时就是处于了运行状态。

4. 阻塞：当线程对象遇到了某些情况后，放弃了cpu当前的使用权，退出来让给其他线程对象执行。此时本线程对象就处于了阻塞状态。处于阻塞状态的线程，需要等待某个时机（具体看导致阻塞的原因），重新进入就绪状态，等待cpu的调用，而不是直接恢复执行状态。（就好比在银行窗口办事时，中途有事离开了，回来之后就要重新排队等待叫号了）

 ::: tip 阻塞发生的可能情况

- 等待阻塞：调用了该线程的 wait() 方法，线程进入等待队列。
- 同步阻塞：在线程用到某个共享资源，获取其锁的时候，锁被其他线程对象占用，则本线程进入阻塞状态，等待其他线程释放锁，直到获取到锁为止。
- 其他阻塞：调用sleep()方法或join()方法，或者发出来I/O请求的时候，线程会处于阻塞状态。
 :::

**死亡：在线程执行结束后，就进入了死亡状态。结束的具体情况分为三种：**

- 正常结束：run()或call()方法执行完毕，线程正常结束。（占用的锁会释放）
- 异常结束：线程抛出了异常，导致异常结束。
- 调用stop：调用了线程的stop()方法，结束了线程的执行。（已过时的方法，线程不安全，不推荐）

**在 Java 编程语言中，请描述一下 Servlet 的生命周期？**

Servlet生命周期可被定义为从创建直到毁灭的整个过程。

三个步骤即：初始化--->处理请求--->销毁

创建Servlet对象后--->初始化（调用 init () 方法）--->处理/响应客户端的请求（调用 service() 方法）--->销毁（调用 destroy() 方法，最后由 JVM 的垃圾回收器进行垃圾回收）

1. 初始化阶段

   当客户端向 Servlet 容器发出 HTTP 请求要求访问 Servlet 时，Servlet 容器首先会解析请求，检查内存中是否已经有了该 Servlet 对象，如果有，则直接使用该 Servlet 对象，如果没有，则创建 Servlet 实例对象，然后通过调用 init() 方法实现 Servlet 的初始化工作。需要注意的是，在 Servlet 的整个生命周期内，它的 init() 方法只能被调用一次。

2. 运行阶段（处理请求）

   这是 Servlet 生命周期中最重要的阶段，在这个阶段中，Servlet 容器会为这个请求创建代表 HTTP 请求的 ServletRequest 对象和代表 HTTP 响应的 ServletResponse 对象，然后将它们作为参数传递给 Servlet 的 service() 方法。service() 方法从 ServletRequest 对象中获得客户请求信息并处理该请求，通过 ServletResponse 对象生成响应结果。在 Servlet 的整个生命周期内，对于 Servlet 的每一次访问请求，Servlet 容器都会调用一次 Servlet 的 service() 方法，并且创建新的 ServletRequest 和 ServletResponse 对象，也就是说，service() 方法在 Servlet 的整个生命周期中会被调用多次。

3. 销毁阶段
 当服务器关闭或 Web 应用被移除出容器时，Servlet 随着 Web 应用的关闭而销毁。在销毁 Servlet 之前，Servlet 容器会调用 Servlet 的 destroy() 方法，以便让 Servlet 对象释放它所占用的资源。在 Servlet 的整个生命周期中，destroy() 方法也只能被调用一次。需要注意的是，Servlet 对象一旦创建就会驻留在内存中等待客户端的访问，直到服务器关闭或 Web 应用被移除出容器时，Servlet 对象才会销毁。

**在 Java 编程语言中，请描述一下 Filter 的生命周期？**

Filter的生命周期可分为创建、执行、销毁三个阶段。

1. 创建阶段：Web服务器启动的时候会创建Filter实例对象，并调用init()方法，完成对象的初始化。

2. 执行阶段：当客户端请求目标资源时，服务器会筛选出符合映射条件的Filter，并按照类名的的先后顺序依次执行doFilter() 方法。

3. 销毁阶段：服务器关闭时，Web服务器调用destroy()方法销毁Filter对象。

**请描述一下 GET 请求和 POST 请求的区别？**

- POST 请求更安全（不会作为 url 的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中，GET 请求的是静态资源，则会缓存，如果是数据，则不会缓存）
- POST 请求发送的数据更大（ GET 请求有 url 长度限制，http协议本身不限制，请求长度限制是由浏览器和web服务器决定和设置）
- POST 请求能发送更多的数据类型（GET 请求只能发送ASCII字符）
- 传参方式不同（get请求参数通过url传递， POST 请求放在request body中传递）
- GET 请求产生一个TCP数据包； POST 请求产生两个TCP数据包（GET 请求，浏览器会把http header和data一并发送出去，服务器响应200返回数据； POST 请求，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 返回数据）

**请描述一下重定向和请求转发的区别？**

1. 请求转发是服务器行为、重定向是客户端浏览器行为

2. 请求转发是request对象调用方法、重定向是response对象调用方法

 重定向用法：

 ```java
 response.sendRedirect(url)；
 ```

 请求转发用法：

 ```java
 RequestDispatcher requestDispatcher = request.getRequestDispatcher("/BookListServlet");
 requestDispatcher.forward(request,response);
 ```

 3. 请求转发只有一次请求所以可以实现request域对象中的数据共享，而重定向是多次请求、多次响应

 4. 请求转发的效率要高于重定向

 5. 请求转发url地址栏不变，而重定向会发生变化

 6. 既然请求转发是服务器内部的行为，所以只能访问服务器内部资源！而重定向既然是浏览器行为，地址栏会变，所以可以访问服务器外部资源！

**请简述下 JDBC 编程的步骤？**

 1. 加载数据库驱动

    ```java
    Class.forName("com.mysql.cj.jdbc.Driver");
    ```

 2. 通过 DriverManager 获取数据库连接 Connection 对象

    - 通过 Connection 对象获取 Statement 对象 或PreparedStatement 对象

    - 使用 Statement 或PreparedStatement 对象执行 SQL 语句 （包括使用占位符传参）

    - 操作 ResultSet 结果集

    - 关闭连接,释放资源【先打开得资源 后关闭】

**请简述下 Servlet 编程的步骤？**

1. 配置开发环境（JDK）和安装tomcat服务器软件
2. 创建项目，在项目中 创建一个Java程序类，继承HttpServlet类 ，重写doGet或doPost方法，生成http请求的响应内容
3. 配置WEB.xml文件，添加Servlet-class servelt-name url-pattern配置

**查询 SQL 语句的书写顺序和执行顺序？**

 查询语句书写顺序：select– from- where- group by- having- order by-limit

 查询语句执行顺序：from - where - group by - having - select - order by-limit
